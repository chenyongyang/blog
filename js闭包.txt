适合初学者的JavaScript闭包

关闭不是魔术
本页面介绍了闭包，以便程序员能够理解它们 - 使用正在运行的JavaScript代码。它不适用于大师或功能性程序员。

一旦核心概念得到修复，关闭并不难理解。但是，通过阅读任何有关他们的学术论文或学术导向的信息，他们是不可能理解的！

本文面向具有某种主流语言编程经验的程序员，他们可以阅读以下JavaScript函数：

function sayHello(name) {
  var text = 'Hello ' + name;
  var say = function() { console.log(text); }
  say();
}
sayHello('Joe');
封闭的例子
两句话总结：

封闭是支持一流职能的一种方式; 它是一个表达式，它可以引用其范围内的变量（当它首次被声明时），被赋值给变量，作为参数传递给函数，或作为函数结果返回。

或者，闭包是在函数开始执行时分配的堆栈框架，并且在函数返回后不会释放（就像“堆栈框架”分配在堆上而不是堆栈上！）。

以下代码返回对函数的引用：

function sayHello2(name) {
  var text = 'Hello ' + name; // Local variable
  var say = function() { console.log(text); }
  return say;
}
var say2 = sayHello2('Bob');
say2(); // logs "Hello Bob"
大多数JavaScript程序员都会理解如何将一个函数的引用返回给say2上述代码中的变量（）。如果你不这样做，那么在你学习关闭之前你需要看看这些。使用C的程序员会想到函数返回一个指向函数的指针，而变量say和say2函数都是指向函数的指针。

指向函数的C指针和函数的JavaScript引用之间存在关键区别。在JavaScript中，你可以把一个函数引用变量，既具有指针的函数，以及作为一个隐藏的指针关闭。

上面的代码有一个闭包，因为匿名函数function() { console.log(text); }是在另一个函数内声明的，sayHello2()在这个例子中。在JavaScript中，如果您function在另一个函数中使用关键字，那么您正在创建一个闭包。

在C语言和大多数其他通用语言中，在函数返回后，所有局部变量不再可访问，因为栈帧被破坏。

在JavaScript中，如果你在另一个函数中声明了一个函数，那么从你调用的函数返回后，局部变量可以保持可访问。这是上面演示的，因为我们say2()在返回后调用函数sayHello2()。请注意，我们调用的代码引用了变量text，该变量是函数的局部变量sayHello2()。

function() { console.log(text); } // Output of say2.toString();
看看输出say2.toString()，我们可以看到代码引用了变量text。匿名函数可以引用text哪个保存值，'Hello Bob'因为局部变量sayHello2()保存在闭包中。

神奇的是，在JavaScript中，函数引用还对它创建的闭包有秘密引用 - 类似于委托如何是方法指针加上对对象的秘密引用。

更多例子
出于某种原因，当你阅读关于它们时，关闭似乎很难理解，但是当你看到一些例子时，它们变得清楚它们是如何工作的（我花了一段时间）。我建议仔细研究这些例子，直到你明白它们是如何工作的。如果你在没有完全理解它们如何工作的情况下开始使用闭包，你很快就会创建一些非常奇怪的错误！

例3
这个例子表明局部变量不被复制 - 它们被引用保存。这就好像当外部函数退出时在内存中保留一个栈帧！

function say667() {
  // Local variable that ends up within closure
  var num = 42;
  var say = function() { console.log(num); }
  num++;
  return say;
}
var sayNumber = say667();
sayNumber(); // logs 43
例4
所有这三个全局函数都具有对同一个闭包的共同参考，因为它们都是在一次调用中声明的setupSomeGlobals()。

var gLogNumber, gIncreaseNumber, gSetNumber;
function setupSomeGlobals() {
  // Local variable that ends up within closure
  var num = 42;
  // Store some references to functions as global variables
  gLogNumber = function() { console.log(num); }
  gIncreaseNumber = function() { num++; }
  gSetNumber = function(x) { num = x; }
}

setupSomeGlobals();
gIncreaseNumber();
gLogNumber(); // 43
gSetNumber(5);
gLogNumber(); // 5

var oldLog = gLogNumber;

setupSomeGlobals();
gLogNumber(); // 42

oldLog() // 5
这三个函数共享同一个闭包 - setupSomeGlobals()三个函数定义时的局部变量。

请注意，在上面的示例中，如果setupSomeGlobals()再次调用，则会创建一个新的闭包（堆栈帧！）。老gLogNumber，gIncreaseNumber，gSetNumber变量被改写新的具有新功能关闭。（在JavaScript中，无论何时在另一个函数中声明函数时，每次调用外部函数时都会重新创建内部函数。）

例5
这对许多人来说是一个真正的难题，所以你需要了解它。如果你要在循环中定义一个函数，要非常小心：来自闭包的局部变量不会像你先想的那样动作。

function buildList(list) {
    var result = [];
    for (var i = 0; i < list.length; i++) {
        var item = 'item' + i;
        result.push( function() {console.log(item + ' ' + list[i])} );
    }
    return result;
}

function testList() {
    var fnlist = buildList([1,2,3]);
    // Using j only to help prevent confusion -- could use i.
    for (var j = 0; j < fnlist.length; j++) {
        fnlist[j]();
    }
}

 testList() //logs "item2 undefined" 3 times
该行为result.push( function() {console.log(item + ' ' + list[i])}结果数组添加一个对匿名函数的引用三次。如果你对匿名函数不熟悉，可以这样想：

pointer = function() {console.log(item + ' ' + list[i])};
result.push(pointer);
请注意，当您运行示例时，"item2 undefined"会收到三次警报！这是因为就像前面的例子一样，局部变量只有一个闭包buildList。在线上调用匿名函数时fnlist[j](); 它们都使用相同的单个闭包，并且它们使用当前值i和item该闭包内i的值（3因为循环已完成且item具有值'item2'）。请注意，我们从0开始索引，因此item其值为item2。并且i ++将增加i值3。

例6
此示例显示闭包包含在退出之前在外函数内声明的任何局部变量。请注意，变量alice实际上是在匿名函数之后声明的。匿名函数首先声明; 并且当该函数被调用时，它可以访问该alice变量，因为它们alice处于相同的范围内（JavaScript没有变量提升）。也sayAlice()()只是直接调用返回的函数引用sayAlice()- 它与以前完成的一样，但没有临时变量。

function sayAlice() {
    var say = function() { console.log(alice); }
    // Local variable that ends up within closure
    var alice = 'Hello Alice';
    return say;
}
sayAlice()();// logs "Hello Alice"
棘手：还要注意，say变量也在闭包内部，并且可以通过任何可能在其中声明的其他函数访问sayAlice()，或者可以在内部函数内递归访问。

例子7
最后一个例子显示每个调用为局部变量创建一个单独的闭包。有不按函数声明一个闭合。每个函数调用都有一个闭包。

function newClosure(someNum, someRef) {
    // Local variables that end up within closure
    var num = someNum;
    var anArray = [1,2,3];
    var ref = someRef;
    return function(x) {
        num += x;
        anArray.push(num);
        console.log('num: ' + num +
            '; anArray: ' + anArray.toString() +
            '; ref.someVar: ' + ref.someVar + ';');
      }
}
obj = {someVar: 4};
fn1 = newClosure(4, obj);
fn2 = newClosure(5, obj);
fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4;
fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4;
obj.someVar++;
fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5;
fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5;
概要
如果一切似乎完全不清楚，那么最好的办法就是玩这些例子。阅读解释比理解示例要困难得多。我对闭包和堆栈框架的解释在技术上并不正确 - 它们是为了帮助理解而进行的粗略简化。一旦基本想法得到了解决，您可以稍后获取详细信息。

最后一点：
无论何时function在另一个函数中使用，都会使用闭包。
无论何时eval()在函数内部使用，都会使用闭包。您eval可以引用该函数的局部变量的文本，并且eval您甚至可以通过使用创建新的局部变量eval('var foo = …')
当你new Function(…)在函数中使用（函数构造函数）时，它不会创建闭包。（新函数不能引用外部函数的局部变量。）
JavaScript中的闭包就像保存所有局部变量的副本一样，就像退出函数时一样。
可能最好认为闭包总是只创建一个函数的入口，并且局部变量被添加到闭包中。
每次调用具有闭包的函数时都会保留一组新的局部变量（假设函数内部包含函数声明，并且返回该函数内部的引用或者以某种方式为其保留外部引用）。
两个函数可能看起来像是具有相同的源文本，但由于它们的“隐藏”关闭而具有完全不同的行为。我不认为JavaScript代码实际上可以找出函数引用是否有闭包。
如果你试图做任何动态的源代码修改（例如：）myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));，如果myFunction是闭包（当然，你甚至不会想到在运行时执行源代码字符串替换，但是...），它将不起作用。
可以在函数内的函数声明中获得函数声明 - 并且可以在多个级别上关闭函数。
我认为封闭通常是函数和捕获变量的术语。请注意，我不使用这篇文章中的定义！
我怀疑JavaScript中的闭包与通常在函数式语言中找到的闭包不同。